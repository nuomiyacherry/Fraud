{"remainingRequest":"D:\\工作项目\\部反诈\\node_modules\\babel-loader\\lib\\index.js!D:\\工作项目\\部反诈\\node_modules\\eslint-loader\\index.js??ref--13-0!D:\\工作项目\\部反诈\\src\\utils\\map3d\\components\\scatter\\index.js","dependencies":[{"path":"D:\\工作项目\\部反诈\\src\\utils\\map3d\\components\\scatter\\index.js","mtime":1598758375222},{"path":"D:\\工作项目\\部反诈\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\工作项目\\部反诈\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\工作项目\\部反诈\\node_modules\\eslint-loader\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import _toConsumableArray from \"D:\\\\\\u5DE5\\u4F5C\\u9879\\u76EE\\\\\\u90E8\\u53CD\\u8BC8\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/toConsumableArray\";\nimport \"core-js/modules/es6.string.repeat\";\nimport _slicedToArray from \"D:\\\\\\u5DE5\\u4F5C\\u9879\\u76EE\\\\\\u90E8\\u53CD\\u8BC8\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/slicedToArray\";\nimport _Array$from2 from \"D:\\\\\\u5DE5\\u4F5C\\u9879\\u76EE\\\\\\u90E8\\u53CD\\u8BC8\\\\node_modules\\\\@babel\\\\runtime-corejs2/core-js/array/from\";\nimport \"core-js/modules/es6.string.starts-with\";\nimport _getIterator from \"D:\\\\\\u5DE5\\u4F5C\\u9879\\u76EE\\\\\\u90E8\\u53CD\\u8BC8\\\\node_modules\\\\@babel\\\\runtime-corejs2/core-js/get-iterator\";\nimport _Array$isArray from \"D:\\\\\\u5DE5\\u4F5C\\u9879\\u76EE\\\\\\u90E8\\u53CD\\u8BC8\\\\node_modules\\\\@babel\\\\runtime-corejs2/core-js/array/is-array\";\nimport \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"D:\\\\\\u5DE5\\u4F5C\\u9879\\u76EE\\\\\\u90E8\\u53CD\\u8BC8\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/asyncToGenerator\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _objectSpread from \"D:\\\\\\u5DE5\\u4F5C\\u9879\\u76EE\\\\\\u90E8\\u53CD\\u8BC8\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/objectSpread\";\nimport _classCallCheck from \"D:\\\\\\u5DE5\\u4F5C\\u9879\\u76EE\\\\\\u90E8\\u53CD\\u8BC8\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\\\u5DE5\\u4F5C\\u9879\\u76EE\\\\\\u90E8\\u53CD\\u8BC8\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport * as THREE from 'three';\nimport merge from 'lodash/merge';\nimport extend from 'lodash/extend';\nimport omit from 'lodash/omit';\nimport pick from 'lodash/pick';\nimport cloneDeep from 'lodash/cloneDeep';\nimport Tooltip from '../tooltip/index';\nimport { getTexture } from '../../core/texture';\nimport { _animationEasing, _animationDuration, scatterScale, SCATTER, symbolMap, scatterOpt } from './options';\n\nvar Scatter =\n/*#__PURE__*/\nfunction () {\n  function Scatter(context, options) {\n    _classCallCheck(this, Scatter);\n\n    var necessaryExtendProps = ['container', 'standardLayout', 'mapCenterVectors', 'scene', 'textureLoader', 'TWEEN', 'tweenEasing'];\n    this.defaultOptions = _objectSpread({}, scatterOpt, {\n      data: [// { name: '北京市', ...scatterOpt }\n      ]\n    });\n    this.initOptions(options);\n    extend(this, pick(context, necessaryExtendProps));\n    this.context = context;\n    this.init();\n  }\n\n  _createClass(Scatter, [{\n    key: \"init\",\n    value: function init() {\n      this.allScatters = [];\n      this.rippleGroup = [];\n      this.textures = [];\n      this.lightrays = [];\n      this.scatterEvents = [];\n      this.options.data && this.paint(this.options.data);\n\n      if (this.options.tooltip && this.options.tooltip.show) {\n        this.tooltip = new Tooltip(this.options.tooltip);\n      }\n\n      if (this.context.tooltip.options.triggerOn === 'scatter') {\n        this.tooltip = this.context.tooltip;\n      }\n\n      this.triggerScatterScale();\n    }\n  }, {\n    key: \"initOptions\",\n    value: function initOptions(options) {\n      var _opt = omit(options, ['data']),\n          _scatterOpt = merge({}, scatterOpt, _opt);\n\n      options.data && (this.defaultOptions.data = cloneDeep(options.data).map(function (item) {\n        return merge({}, _scatterOpt, item);\n      }));\n      this.options = merge({}, this.defaultOptions, _scatterOpt);\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options, repaint) {\n      var _this = this;\n\n      if (repaint) {\n        this.allScatters.forEach(function (item) {\n          _this.context.remove(item);\n        });\n        this.initOptions(options);\n        this.init();\n      } else {\n        var data = cloneDeep(options).map(function (item) {\n          return merge({}, scatterOpt, item);\n        });\n        this.paint(data);\n      }\n    }\n  }, {\n    key: \"triggerScatterScale\",\n    value: function triggerScatterScale() {\n      var trigger = this.tooltip ? this.tooltip.options.trigger : 'mousemove';\n      this.context.registerMouseEvent(trigger, this.setActiveScatter.bind(this), this.allScatters);\n    }\n  }, {\n    key: \"setActiveScatter\",\n    value: function setActiveScatter(event) {\n      var intersect = event.intersects[0];\n\n      if (this.activeScatter) {\n        this.activeScatter.scale.set(1, 1, 1);\n        this.container.style.cursor = 'default';\n        this.activeScatter = null;\n        this.tooltip && this.tooltip.hide(event);\n      }\n\n      if (!intersect) return;\n      var object = intersect.object,\n          group = object.parent;\n\n      if (group instanceof THREE.Group && group.name.toLowerCase().indexOf(SCATTER) > -1) {\n        var scatter = group.getObjectByName(SCATTER);\n\n        if (scatter) {\n          scatter.scale.set(scatterScale, scatterScale, scatterScale);\n          this.activeScatter = scatter;\n          this.container.style.cursor = 'pointer';\n          this.tooltip && this.tooltip.show(_objectSpread({\n            type: object.name,\n            object: group\n          }, group.data, {\n            event: event\n          }));\n        }\n      }\n    }\n  }, {\n    key: \"controlScatters\",\n    value: function controlScatters(params) {\n      var min = params.min,\n          max = params.max,\n          show = params.show,\n          zoom = params.zoom,\n          hideOther = params.hideOther,\n          range = params.range;\n      this.allScatters.forEach(function (group) {\n        var value = (group.data.data || {}).value || 0;\n\n        if (!min && !max) {\n          var _scatter = group.getObjectByName('scatter');\n\n          _scatter.scale.set(1, 1, 1);\n\n          return;\n        }\n\n        if (range && (value < range.min || value > range.max)) return;\n        var scatter = group.getObjectByName('scatter');\n\n        if (min <= value && max >= value) {\n          if (show) {\n            zoom ? scatter.scale.set(scatterScale, scatterScale, scatterScale) : scatter.scale.set(1, 1, 1);\n            group.visible = true;\n          } else {\n            group.visible = false;\n          }\n        } else {\n          scatter.scale.set(1, 1, 1);\n\n          if (hideOther) {\n            group.visible = false;\n          }\n        }\n      });\n    }\n  }, {\n    key: \"paint\",\n    value: function () {\n      var _paint = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee(data) {\n        var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, d, group, show, color, symbol, size, offset, effectType, effect, center, lightray, name, _data, model, position, options, mesh, isCustomSymbol, period, brushType, scale, drawFn, _i, _Array$from, k, _mesh2, _mesh;\n\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (_Array$isArray(data)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 2:\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _iteratorError = undefined;\n                _context.prev = 5;\n                _iterator = _getIterator(data);\n\n              case 7:\n                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                  _context.next = 59;\n                  break;\n                }\n\n                d = _step.value;\n                group = new THREE.Group(), show = d.show, color = d.color, symbol = d.symbol, size = d.size, offset = d.offset, effectType = d.effectType, effect = d.effect, center = d.center, lightray = d.lightray, name = d.name, _data = d.data, model = this.scene.getObjectByName(name) || this.scene, position = center ? this.context.coordToVector3(center.slice(0, 2), center[3]) : this.mapCenterVectors[name], options = {\n                  color: color,\n                  show: show,\n                  size: size / this.standardLayout.zoom\n                };\n\n                if (position) {\n                  _context.next = 12;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 12:\n                mesh = void 0, isCustomSymbol = false;\n\n                if (offset && _Array$isArray(offset)) {\n                  offset[0] && (position[0] += offset[0]);\n                  offset[1] && (position[1] += offset[1]);\n                  offset[2] && (position[2] += offset[2]);\n                }\n\n                position[2] += 0.1 / this.standardLayout.zoom;\n                options.position = position;\n                this.lightrays.push({\n                  name: name,\n                  options: lightray,\n                  position: position\n                });\n\n                if (!(typeof symbol === 'number')) {\n                  _context.next = 22;\n                  break;\n                }\n\n                options.segments = symbol;\n                mesh = this.drawRegularPolygonMesh(_objectSpread({}, options));\n                _context.next = 32;\n                break;\n\n              case 22:\n                if (!symbol.startsWith('image://')) {\n                  _context.next = 30;\n                  break;\n                }\n\n                options.symbol = symbol;\n                isCustomSymbol = true;\n                _context.next = 27;\n                return this.drawCustomSymbol(_objectSpread({}, options));\n\n              case 27:\n                mesh = _context.sent;\n                _context.next = 32;\n                break;\n\n              case 30:\n                options.segments = symbolMap[symbol];\n                mesh = this.drawRegularPolygonMesh(_objectSpread({}, options));\n\n              case 32:\n                mesh.name = SCATTER;\n                group.name = \"\".concat(name, \"_\").concat(SCATTER);\n                group.data = {\n                  data: _data,\n                  name: name\n                };\n                group.add(mesh);\n\n                if (!(effectType === 'ripple')) {\n                  _context.next = 53;\n                  break;\n                }\n\n                period = effect.period, brushType = effect.brushType, scale = effect.scale, drawFn = isCustomSymbol ? 'drawCustomSymbol' : brushType === 'fill' ? 'drawRegularPolygonMesh' : 'drawRegularPolygonLine';\n                _i = 0, _Array$from = _Array$from2({\n                  length: period - 1\n                });\n\n              case 39:\n                if (!(_i < _Array$from.length)) {\n                  _context.next = 49;\n                  break;\n                }\n\n                k = _Array$from[_i];\n                _context.next = 43;\n                return this[drawFn](_objectSpread({}, options));\n\n              case 43:\n                _mesh2 = _context.sent;\n                _mesh2.name = 'effectScatter';\n                group.add(_mesh2);\n\n              case 46:\n                _i++;\n                _context.next = 39;\n                break;\n\n              case 49:\n                // Array.from({length: period - 1}).forEach((item, i) => {\n                //   const mesh = this[drawFn]({...options})\n                //   mesh.name = 'effectScatter'\n                //   group.add(mesh)\n                // })\n                group.scaleEnd = scale;\n                this.rippleGroup.push(group);\n                _context.next = 54;\n                break;\n\n              case 53:\n                if (!isCustomSymbol) {\n                  _mesh = mesh.clone();\n                  _mesh.material.opacity = 0.5;\n\n                  _mesh.scale.set(1.25, 1.25, 1.5);\n\n                  group.add(_mesh);\n                }\n\n              case 54:\n                this.allScatters.push(group);\n                model.add(group);\n\n              case 56:\n                _iteratorNormalCompletion = true;\n                _context.next = 7;\n                break;\n\n              case 59:\n                _context.next = 65;\n                break;\n\n              case 61:\n                _context.prev = 61;\n                _context.t0 = _context[\"catch\"](5);\n                _didIteratorError = true;\n                _iteratorError = _context.t0;\n\n              case 65:\n                _context.prev = 65;\n                _context.prev = 66;\n\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                  _iterator.return();\n                }\n\n              case 68:\n                _context.prev = 68;\n\n                if (!_didIteratorError) {\n                  _context.next = 71;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 71:\n                return _context.finish(68);\n\n              case 72:\n                return _context.finish(65);\n\n              case 73:\n                this.effectScatterRipple();\n                this.drawLightrays();\n\n              case 75:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[5, 61, 65, 73], [66,, 68, 72]]);\n      }));\n\n      function paint(_x) {\n        return _paint.apply(this, arguments);\n      }\n\n      return paint;\n    }()\n  }, {\n    key: \"drawCustomSymbol\",\n    value: function () {\n      var _drawCustomSymbol = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee2(options) {\n        var size, color, position, show, symbol, texture, geometry, material, plane, _position, x, y, z;\n\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                size = options.size;\n                color = options.color;\n                position = options.position;\n                show = options.show;\n                symbol = options.symbol;\n                _context2.next = 7;\n                return getTexture(symbol);\n\n              case 7:\n                texture = _context2.sent;\n                geometry = new THREE.PlaneBufferGeometry(size * 2, size * 2);\n                material = new THREE.MeshBasicMaterial({\n                  map: texture,\n                  // color,\n                  depthTest: false,\n                  transparent: true,\n                  side: THREE.DoubleSide,\n                  blending: THREE.AdditiveBlending\n                });\n                plane = new THREE.Mesh(geometry, material);\n                _position = _slicedToArray(position, 3);\n                x = _position[0];\n                y = _position[1];\n                z = _position[2];\n                plane.position.set(x, y, z); // plane.rotation.y = Math.PI / 2\n\n                plane.rotation.z = Math.PI / 2;\n                plane.visible = show;\n                return _context2.abrupt(\"return\", plane);\n\n              case 19:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function drawCustomSymbol(_x2) {\n        return _drawCustomSymbol.apply(this, arguments);\n      }\n\n      return drawCustomSymbol;\n    }()\n  }, {\n    key: \"effectScatterRipple\",\n    value: function effectScatterRipple() {\n      var _this2 = this;\n\n      !this.rippleGroupTween && (this.rippleGroupTween = new this.TWEEN.Group());\n      this.rippleGroupTween.removeAll();\n      var _this$options = this.options,\n          _this$options$animati = _this$options.animationEasing,\n          animationEasing = _this$options$animati === void 0 ? _animationEasing : _this$options$animati,\n          _this$options$animati2 = _this$options.animationDuration,\n          animationDuration = _this$options$animati2 === void 0 ? _animationDuration : _this$options$animati2,\n          easing = this.tweenEasing[animationEasing];\n      this.rippleGroup.forEach(function (group) {\n        var meshes = group.children;\n\n        if (meshes) {\n          var scale = group.scaleEnd,\n              delay = animationDuration / meshes.length;\n          meshes.forEach(function (mesh, i) {\n            if (mesh.name === 'effectScatter') {\n              var start = {\n                scale: 1,\n                opacity: 1\n              },\n                  end = {\n                scale: scale,\n                opacity: 0\n              };\n              new _this2.TWEEN.Tween(start, _this2.rippleGroupTween).to(end, animationDuration).easing(easing).delay(delay * i).repeat(Infinity).onUpdate(function (obj) {\n                var scale = obj.scale,\n                    opacity = obj.opacity;\n                mesh.material.opacity = opacity;\n                mesh.scale.set(scale, scale, scale);\n              }).start();\n            }\n          });\n        }\n      });\n      new this.TWEEN.Tween(this, this.rippleGroupTween).to({}, animationDuration).delay(50).start();\n    }\n  }, {\n    key: \"lightrayAnimate\",\n    value: function lightrayAnimate() {\n      var _this3 = this;\n\n      !this.lightrayTween && (this.lightrayTween = new this.TWEEN.Group());\n      this.lightrayTween.removeAll();\n      this.lightrayArray.forEach(function (mesh) {\n        new _this3.TWEEN.Tween(mesh.geometry.parameters, _this3.lightrayTween).to({\n          height: mesh.height\n        }, 1500).easing(_this3.tweenEasing[_animationEasing]).start().onComplete(function (_) {\n          // console.log(_, mesh.height)\n          _this3.lightrayTween.removeAll();\n\n          _this3.lightrayTween = null;\n        });\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.rippleGroupTween && this.rippleGroupTween.update();\n      this.lightrayTween && this.lightrayTween.update();\n    } // 画多边形\n\n  }, {\n    key: \"drawRegularPolygonMesh\",\n    value: function drawRegularPolygonMesh(_ref) {\n      var _mesh$position;\n\n      var _ref$size = _ref.size,\n          size = _ref$size === void 0 ? 6 : _ref$size,\n          _ref$segments = _ref.segments,\n          segments = _ref$segments === void 0 ? 6 : _ref$segments,\n          color = _ref.color,\n          position = _ref.position,\n          show = _ref.show;\n      var geometry = new THREE.CircleBufferGeometry(size, segments),\n          material = new THREE.MeshBasicMaterial({\n        color: color,\n        transparent: true\n      }),\n          mesh = new THREE.Mesh(geometry, material);\n\n      (_mesh$position = mesh.position).set.apply(_mesh$position, _toConsumableArray(position));\n\n      mesh.visible = show;\n      return mesh;\n    } // 画多边形的边线\n\n  }, {\n    key: \"drawRegularPolygonLine\",\n    value: function drawRegularPolygonLine(_ref2) {\n      var _line$position;\n\n      var _ref2$size = _ref2.size,\n          size = _ref2$size === void 0 ? 8 : _ref2$size,\n          _ref2$segments = _ref2.segments,\n          segments = _ref2$segments === void 0 ? 6 : _ref2$segments,\n          color = _ref2.color,\n          position = _ref2.position,\n          show = _ref2.show;\n      var geometry = new THREE.CircleGeometry(size, segments),\n          material = new THREE.MeshBasicMaterial({\n        color: color,\n        transparent: true\n      });\n      geometry.vertices.shift();\n      var line = new THREE.LineLoop(geometry, material);\n\n      (_line$position = line.position).set.apply(_line$position, _toConsumableArray(position));\n\n      line.visible = show;\n      return line;\n    }\n  }, {\n    key: \"drawLightrays\",\n    value: function () {\n      var _drawLightrays = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee3() {\n        var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, value;\n\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this.lightrayArray = [];\n                _iteratorNormalCompletion2 = true;\n                _didIteratorError2 = false;\n                _iteratorError2 = undefined;\n                _context3.prev = 4;\n                _iterator2 = _getIterator(this.lightrays);\n\n              case 6:\n                if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {\n                  _context3.next = 13;\n                  break;\n                }\n\n                value = _step2.value;\n                _context3.next = 10;\n                return this.drawLightray(value);\n\n              case 10:\n                _iteratorNormalCompletion2 = true;\n                _context3.next = 6;\n                break;\n\n              case 13:\n                _context3.next = 19;\n                break;\n\n              case 15:\n                _context3.prev = 15;\n                _context3.t0 = _context3[\"catch\"](4);\n                _didIteratorError2 = true;\n                _iteratorError2 = _context3.t0;\n\n              case 19:\n                _context3.prev = 19;\n                _context3.prev = 20;\n\n                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                  _iterator2.return();\n                }\n\n              case 22:\n                _context3.prev = 22;\n\n                if (!_didIteratorError2) {\n                  _context3.next = 25;\n                  break;\n                }\n\n                throw _iteratorError2;\n\n              case 25:\n                return _context3.finish(22);\n\n              case 26:\n                return _context3.finish(19);\n\n              case 27:\n                this.lightrayAnimate();\n\n              case 28:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[4, 15, 19, 27], [20,, 22, 26]]);\n      }));\n\n      function drawLightrays() {\n        return _drawLightrays.apply(this, arguments);\n      }\n\n      return drawLightrays;\n    }()\n  }, {\n    key: \"drawLightray\",\n    value: function () {\n      var _drawLightray = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee4(_ref3) {\n        var name, options, position, src, width, height, texture, lightray1, model, lightray2;\n        return regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                name = _ref3.name, options = _ref3.options, position = _ref3.position;\n                src = options.texture;\n                width = options.width;\n                height = options.height;\n                _context4.next = 6;\n                return getTexture(src);\n\n              case 6:\n                texture = _context4.sent;\n                lightray1 = this.drawPlane(_objectSpread({}, options, {\n                  texture: texture,\n                  position: position,\n                  width: width / this.standardLayout.zoom,\n                  height: height / this.standardLayout.zoom\n                })), model = this.scene.getObjectByName(\"\".concat(name, \"_\").concat(SCATTER)) || this.scene;\n                lightray1.name = \"\".concat(name, \"_lightray\");\n                lightray2 = lightray1.clone();\n                lightray2.rotation.y = Math.PI / 2;\n                model.add(lightray1);\n                model.add(lightray2);\n                this.lightrayArray.push(lightray1, lightray2);\n\n              case 14:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function drawLightray(_x3) {\n        return _drawLightray.apply(this, arguments);\n      }\n\n      return drawLightray;\n    }()\n  }, {\n    key: \"drawPlane\",\n    value: function drawPlane(_ref4) {\n      var _ref4$position = _ref4.position,\n          position = _ref4$position === void 0 ? [0, 0, 0] : _ref4$position,\n          _ref4$show = _ref4.show,\n          show = _ref4$show === void 0 ? true : _ref4$show,\n          _ref4$color = _ref4.color,\n          color = _ref4$color === void 0 ? 'red' : _ref4$color,\n          _ref4$width = _ref4.width,\n          width = _ref4$width === void 0 ? 6 : _ref4$width,\n          _ref4$height = _ref4.height,\n          height = _ref4$height === void 0 ? 10 : _ref4$height,\n          _ref4$widthSegments = _ref4.widthSegments,\n          widthSegments = _ref4$widthSegments === void 0 ? 1 : _ref4$widthSegments,\n          _ref4$heightSegments = _ref4.heightSegments,\n          heightSegments = _ref4$heightSegments === void 0 ? 1 : _ref4$heightSegments,\n          _ref4$opacity = _ref4.opacity,\n          opacity = _ref4$opacity === void 0 ? 1 : _ref4$opacity,\n          _ref4$texture = _ref4.texture,\n          texture = _ref4$texture === void 0 ? '' : _ref4$texture;\n\n      var geometry = new THREE.PlaneBufferGeometry(width * 2, height * 2, // 1,\n      widthSegments, heightSegments),\n          material = new THREE.MeshBasicMaterial({\n        map: texture,\n        opacity: opacity,\n        color: color,\n        depthTest: false,\n        transparent: true,\n        side: THREE.DoubleSide,\n        // blending: THREE.AdditiveBlending\n        blending: THREE.CustomBlending,\n        blendEquation: THREE.AddEquation,\n        blendSrc: THREE.OneFactor,\n        blendDst: THREE.OneFactor,\n        blendSrcAlpha: 1\n      }),\n          plane = new THREE.Mesh(geometry, material),\n          _position2 = _slicedToArray(position, 3),\n          x = _position2[0],\n          y = _position2[1],\n          z = _position2[2];\n\n      plane.position.set(x, y, z + height); // plane.height = height * 2\n\n      plane.rotation.x = Math.PI / 2;\n      plane.rotation.z = Math.PI;\n      plane.visible = show;\n      return plane;\n    }\n  }]);\n\n  return Scatter;\n}();\n\nexport { Scatter as default };",{"version":3,"sources":["D:\\工作项目\\部反诈\\src\\utils\\map3d\\components\\scatter\\index.js"],"names":["THREE","merge","extend","omit","pick","cloneDeep","Tooltip","getTexture","_animationEasing","_animationDuration","scatterScale","SCATTER","symbolMap","scatterOpt","Scatter","context","options","necessaryExtendProps","defaultOptions","data","initOptions","init","allScatters","rippleGroup","textures","lightrays","scatterEvents","paint","tooltip","show","triggerOn","triggerScatterScale","_opt","_scatterOpt","map","item","repaint","forEach","remove","trigger","registerMouseEvent","setActiveScatter","bind","event","intersect","intersects","activeScatter","scale","set","container","style","cursor","hide","object","group","parent","Group","name","toLowerCase","indexOf","scatter","getObjectByName","type","params","min","max","zoom","hideOther","range","value","visible","d","color","symbol","size","offset","effectType","effect","center","lightray","model","scene","position","coordToVector3","slice","mapCenterVectors","standardLayout","mesh","isCustomSymbol","push","segments","drawRegularPolygonMesh","startsWith","drawCustomSymbol","add","period","brushType","drawFn","length","k","scaleEnd","_mesh","clone","material","opacity","effectScatterRipple","drawLightrays","texture","geometry","PlaneBufferGeometry","MeshBasicMaterial","depthTest","transparent","side","DoubleSide","blending","AdditiveBlending","plane","Mesh","x","y","z","rotation","Math","PI","rippleGroupTween","TWEEN","removeAll","animationEasing","animationDuration","easing","tweenEasing","meshes","children","delay","i","start","end","Tween","to","repeat","Infinity","onUpdate","obj","lightrayTween","lightrayArray","parameters","height","onComplete","_","update","CircleBufferGeometry","CircleGeometry","vertices","shift","line","LineLoop","drawLightray","lightrayAnimate","src","width","lightray1","drawPlane","lightray2","widthSegments","heightSegments","CustomBlending","blendEquation","AddEquation","blendSrc","OneFactor","blendDst","blendSrcAlpha"],"mappings":"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","sourcesContent":["import * as THREE from 'three'\nimport merge from 'lodash/merge'\nimport extend from 'lodash/extend'\nimport omit from 'lodash/omit'\nimport pick from 'lodash/pick'\nimport cloneDeep from 'lodash/cloneDeep'\nimport Tooltip from '../tooltip/index'\nimport {getTexture} from '../../core/texture'\nimport {\n  _animationEasing,\n  _animationDuration,\n  scatterScale,\n  SCATTER,\n  symbolMap,\n  scatterOpt\n} from './options'\n\nexport default class Scatter {\n  constructor(context, options) {\n    const necessaryExtendProps = [\n      'container',\n      'standardLayout',\n      'mapCenterVectors',\n      'scene',\n      'textureLoader',\n      'TWEEN',\n      'tweenEasing'\n    ]\n    this.defaultOptions = {\n      ...scatterOpt,\n      data: [\n        // { name: '北京市', ...scatterOpt }\n      ]\n    }\n    this.initOptions(options)\n    extend(this, pick(context, necessaryExtendProps))\n\n    this.context = context\n    this.init()\n  }\n\n  init() {\n    this.allScatters = []\n    this.rippleGroup = []\n    this.textures = []\n    this.lightrays = []\n    this.scatterEvents = []\n    this.options.data && this.paint(this.options.data)\n    if (this.options.tooltip && this.options.tooltip.show) {\n      this.tooltip = new Tooltip(this.options.tooltip)\n    }\n    if (this.context.tooltip.options.triggerOn === 'scatter') {\n      this.tooltip = this.context.tooltip\n    }\n    this.triggerScatterScale()\n  }\n\n  initOptions(options) {\n    const _opt = omit(options, ['data']),\n      _scatterOpt = merge({}, scatterOpt, _opt)\n    options.data &&\n      (this.defaultOptions.data = cloneDeep(options.data).map(item =>\n        merge({}, _scatterOpt, item)\n      ))\n    this.options = merge({}, this.defaultOptions, _scatterOpt)\n  }\n\n  setOptions(options, repaint) {\n    if (repaint) {\n      this.allScatters.forEach(item => {\n        this.context.remove(item)\n      })\n      this.initOptions(options)\n      this.init()\n    } else {\n      const data = cloneDeep(options).map(item => merge({}, scatterOpt, item))\n      this.paint(data)\n    }\n  }\n\n  triggerScatterScale() {\n    const trigger = this.tooltip ? this.tooltip.options.trigger : 'mousemove'\n    this.context.registerMouseEvent(\n      trigger,\n      this.setActiveScatter.bind(this),\n      this.allScatters\n    )\n  }\n\n  setActiveScatter(event) {\n    const intersect = event.intersects[0]\n    if (this.activeScatter) {\n      this.activeScatter.scale.set(1, 1, 1)\n      this.container.style.cursor = 'default'\n      this.activeScatter = null\n      this.tooltip && this.tooltip.hide(event)\n    }\n    if (!intersect) return\n    const object = intersect.object,\n      group = object.parent\n    if (\n      group instanceof THREE.Group &&\n      group.name.toLowerCase().indexOf(SCATTER) > -1\n    ) {\n      const scatter = group.getObjectByName(SCATTER)\n      if (scatter) {\n        scatter.scale.set(scatterScale, scatterScale, scatterScale)\n        this.activeScatter = scatter\n        this.container.style.cursor = 'pointer'\n        this.tooltip &&\n          this.tooltip.show({\n            type: object.name,\n            object: group,\n            ...group.data,\n            event\n          })\n      }\n    }\n  }\n\n  controlScatters(params) {\n    const {min, max, show, zoom, hideOther, range} = params\n    this.allScatters.forEach(group => {\n      const value = (group.data.data || {}).value || 0\n      if (!min && !max) {\n        const scatter = group.getObjectByName('scatter')\n        scatter.scale.set(1, 1, 1)\n        return\n      }\n      if (range && (value < range.min || value > range.max)) return\n      const scatter = group.getObjectByName('scatter')\n      if (min <= value && max >= value) {\n        if (show) {\n          zoom\n            ? scatter.scale.set(scatterScale, scatterScale, scatterScale)\n            : scatter.scale.set(1, 1, 1)\n          group.visible = true\n        } else {\n          group.visible = false\n        }\n      } else {\n        scatter.scale.set(1, 1, 1)\n        if (hideOther) {\n          group.visible = false\n        }\n      }\n    })\n  }\n\n  async paint(data) {\n    if (!Array.isArray(data)) return\n    for (let d of data) {\n      const group = new THREE.Group(),\n        {\n          show,\n          color,\n          symbol,\n          size,\n          offset,\n          effectType,\n          effect,\n          center,\n          lightray,\n          name,\n          data\n        } = d,\n        model = this.scene.getObjectByName(name) || this.scene,\n        position = center\n          ? this.context.coordToVector3(center.slice(0, 2), center[3])\n          : this.mapCenterVectors[name],\n        options = {\n          color,\n          show,\n          size: size / this.standardLayout.zoom\n        }\n      if (!position) return\n\n      let mesh,\n        isCustomSymbol = false\n      if (offset && Array.isArray(offset)) {\n        offset[0] && (position[0] += offset[0])\n        offset[1] && (position[1] += offset[1])\n        offset[2] && (position[2] += offset[2])\n      }\n      position[2] += 0.1 / this.standardLayout.zoom\n      options.position = position\n      this.lightrays.push({\n        name,\n        options: lightray,\n        position\n      })\n      if (typeof symbol === 'number') {\n        options.segments = symbol\n        mesh = this.drawRegularPolygonMesh({...options})\n      } else {\n        if (symbol.startsWith('image://')) {\n          options.symbol = symbol\n          isCustomSymbol = true\n          mesh = await this.drawCustomSymbol({...options})\n        } else {\n          options.segments = symbolMap[symbol]\n          mesh = this.drawRegularPolygonMesh({...options})\n        }\n      }\n      mesh.name = SCATTER\n      group.name = `${name}_${SCATTER}`\n      group.data = {\n        data,\n        name\n      }\n      group.add(mesh)\n      if (effectType === 'ripple') {\n        const {period, brushType, scale} = effect,\n          drawFn = isCustomSymbol\n            ? 'drawCustomSymbol'\n            : brushType === 'fill'\n            ? 'drawRegularPolygonMesh'\n            : 'drawRegularPolygonLine'\n        for (let k of Array.from({length: period - 1})) {\n          const mesh = await this[drawFn]({...options})\n          mesh.name = 'effectScatter'\n          group.add(mesh)\n        }\n        // Array.from({length: period - 1}).forEach((item, i) => {\n        //   const mesh = this[drawFn]({...options})\n        //   mesh.name = 'effectScatter'\n        //   group.add(mesh)\n        // })\n        group.scaleEnd = scale\n        this.rippleGroup.push(group)\n      } else {\n        if (!isCustomSymbol) {\n          const _mesh = mesh.clone()\n          _mesh.material.opacity = 0.5\n          _mesh.scale.set(1.25, 1.25, 1.5)\n          group.add(_mesh)\n        }\n      }\n      this.allScatters.push(group)\n      model.add(group)\n    }\n    this.effectScatterRipple()\n    this.drawLightrays()\n  }\n\n  async drawCustomSymbol(options) {\n    const {size, color, position, show, symbol} = options,\n      texture = await getTexture(symbol),\n      geometry = new THREE.PlaneBufferGeometry(size * 2, size * 2),\n      material = new THREE.MeshBasicMaterial({\n        map: texture,\n        // color,\n        depthTest: false,\n        transparent: true,\n        side: THREE.DoubleSide,\n        blending: THREE.AdditiveBlending\n      }),\n      plane = new THREE.Mesh(geometry, material),\n      [x, y, z] = position\n    plane.position.set(x, y, z)\n    // plane.rotation.y = Math.PI / 2\n    plane.rotation.z = Math.PI / 2\n    plane.visible = show\n    return plane\n  }\n\n  effectScatterRipple() {\n    !this.rippleGroupTween && (this.rippleGroupTween = new this.TWEEN.Group())\n    this.rippleGroupTween.removeAll()\n    const {\n        animationEasing = _animationEasing,\n        animationDuration = _animationDuration\n      } = this.options,\n      easing = this.tweenEasing[animationEasing]\n    this.rippleGroup.forEach(group => {\n      const meshes = group.children\n      if (meshes) {\n        const scale = group.scaleEnd,\n          delay = animationDuration / meshes.length\n        meshes.forEach((mesh, i) => {\n          if (mesh.name === 'effectScatter') {\n            const start = {\n                scale: 1,\n                opacity: 1\n              },\n              end = {\n                scale,\n                opacity: 0\n              }\n            new this.TWEEN.Tween(start, this.rippleGroupTween)\n              .to(end, animationDuration)\n              .easing(easing)\n              .delay(delay * i)\n              .repeat(Infinity)\n              .onUpdate(obj => {\n                const {scale, opacity} = obj\n                mesh.material.opacity = opacity\n                mesh.scale.set(scale, scale, scale)\n              })\n              .start()\n          }\n        })\n      }\n    })\n    new this.TWEEN.Tween(this, this.rippleGroupTween)\n      .to({}, animationDuration)\n      .delay(50)\n      .start()\n  }\n\n  lightrayAnimate() {\n    !this.lightrayTween && (this.lightrayTween = new this.TWEEN.Group())\n    this.lightrayTween.removeAll()\n    this.lightrayArray.forEach(mesh => {\n      new this.TWEEN.Tween(mesh.geometry.parameters, this.lightrayTween)\n        .to({height: mesh.height}, 1500)\n        .easing(this.tweenEasing[_animationEasing])\n        .start()\n        .onComplete(_ => {\n          // console.log(_, mesh.height)\n          this.lightrayTween.removeAll()\n          this.lightrayTween = null\n        })\n    })\n  }\n\n  render() {\n    this.rippleGroupTween && this.rippleGroupTween.update()\n    this.lightrayTween && this.lightrayTween.update()\n  }\n\n  // 画多边形\n  drawRegularPolygonMesh({size = 6, segments = 6, color, position, show}) {\n    const geometry = new THREE.CircleBufferGeometry(size, segments),\n      material = new THREE.MeshBasicMaterial({\n        color,\n        transparent: true\n      }),\n      mesh = new THREE.Mesh(geometry, material)\n    mesh.position.set(...position)\n    mesh.visible = show\n    return mesh\n  }\n\n  // 画多边形的边线\n  drawRegularPolygonLine({size = 8, segments = 6, color, position, show}) {\n    const geometry = new THREE.CircleGeometry(size, segments),\n      material = new THREE.MeshBasicMaterial({\n        color,\n        transparent: true\n      })\n    geometry.vertices.shift()\n    const line = new THREE.LineLoop(geometry, material)\n    line.position.set(...position)\n    line.visible = show\n    return line\n  }\n\n  async drawLightrays() {\n    this.lightrayArray = []\n    for (let value of this.lightrays) {\n      await this.drawLightray(value)\n    }\n    this.lightrayAnimate()\n  }\n\n  async drawLightray({name, options, position}) {\n    const {texture: src, width, height} = options,\n      texture = await getTexture(src)\n    const lightray1 = this.drawPlane({\n        ...options,\n        texture,\n        position,\n        width: width / this.standardLayout.zoom,\n        height: height / this.standardLayout.zoom\n      }),\n      model = this.scene.getObjectByName(`${name}_${SCATTER}`) || this.scene\n    lightray1.name = `${name}_lightray`\n    const lightray2 = lightray1.clone()\n    lightray2.rotation.y = Math.PI / 2\n    model.add(lightray1)\n    model.add(lightray2)\n    this.lightrayArray.push(lightray1, lightray2)\n  }\n\n  drawPlane({\n    position = [0, 0, 0],\n    show = true,\n    color = 'red',\n    width = 6,\n    height = 10,\n    widthSegments = 1,\n    heightSegments = 1,\n    opacity = 1,\n    texture = ''\n  }) {\n    const geometry = new THREE.PlaneBufferGeometry(\n        width * 2,\n        height * 2,\n        // 1,\n        widthSegments,\n        heightSegments\n      ),\n      material = new THREE.MeshBasicMaterial({\n        map: texture,\n        opacity,\n        color,\n        depthTest: false,\n        transparent: true,\n        side: THREE.DoubleSide,\n        // blending: THREE.AdditiveBlending\n        blending: THREE.CustomBlending,\n        blendEquation: THREE.AddEquation,\n        blendSrc: THREE.OneFactor,\n        blendDst: THREE.OneFactor,\n        blendSrcAlpha: 1\n      }),\n      plane = new THREE.Mesh(geometry, material),\n      [x, y, z] = position\n    plane.position.set(x, y, z + height)\n    // plane.height = height * 2\n    plane.rotation.x = Math.PI / 2\n    plane.rotation.z = Math.PI\n    plane.visible = show\n    return plane\n  }\n}\n"]}]}