{"remainingRequest":"D:\\工作项目\\部反诈\\node_modules\\babel-loader\\lib\\index.js!D:\\工作项目\\部反诈\\node_modules\\eslint-loader\\index.js??ref--13-0!D:\\工作项目\\部反诈\\src\\utils\\map3d\\core\\decode.js","dependencies":[{"path":"D:\\工作项目\\部反诈\\src\\utils\\map3d\\core\\decode.js","mtime":1598758375242},{"path":"D:\\工作项目\\部反诈\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\工作项目\\部反诈\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\工作项目\\部反诈\\node_modules\\eslint-loader\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/web.dom.iterable\";\nimport _slicedToArray from \"D:\\\\\\u5DE5\\u4F5C\\u9879\\u76EE\\\\\\u90E8\\u53CD\\u8BC8\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/slicedToArray\";\nexport function decodePolygon(coordinate, encodeOffsets, encodeScale) {\n  var result = [];\n\n  var _encodeOffsets = _slicedToArray(encodeOffsets, 2),\n      prevX = _encodeOffsets[0],\n      prevY = _encodeOffsets[1];\n\n  for (var i = 0; i < coordinate.length; i += 2) {\n    var x = coordinate.charCodeAt(i) - 64,\n        y = coordinate.charCodeAt(i + 1) - 64; // ZigZag decoding\n\n    x = x >> 1 ^ -(x & 1);\n    y = y >> 1 ^ -(y & 1); // Delta decoding\n\n    x += prevX;\n    y += prevY;\n    prevX = x;\n    prevY = y; // Dequantize\n\n    result.push([x / encodeScale, y / encodeScale]);\n  }\n\n  return result;\n} // 地图json解码\n\nexport default function decode(json) {\n  if (!json.UTF8Encoding) return json;\n  var encodeScale = json.UTF8Scale;\n\n  if (!encodeScale) {\n    encodeScale = 1024;\n  }\n\n  json.features.forEach(function (feature) {\n    var geometry = feature.geometry,\n        coordinates = geometry.coordinates,\n        encodeOffsets = geometry.encodeOffsets;\n    coordinates.forEach(function (coordinate, c) {\n      if (geometry.type === 'Polygon') {\n        coordinates[c] = decodePolygon(coordinate, encodeOffsets[c], encodeScale);\n      } else if (geometry.type === 'MultiPolygon') {\n        coordinate.forEach(function (polygon, c2) {\n          coordinate[c2] = decodePolygon(polygon, encodeOffsets[c][c2], encodeScale);\n        });\n      }\n    });\n  }); // has been decoded\n\n  json.UTF8Encoding = false;\n  return json;\n}",{"version":3,"sources":["D:\\工作项目\\部反诈\\src\\utils\\map3d\\core\\decode.js"],"names":["decodePolygon","coordinate","encodeOffsets","encodeScale","result","prevX","prevY","i","length","x","charCodeAt","y","push","decode","json","UTF8Encoding","UTF8Scale","features","forEach","feature","geometry","coordinates","c","type","polygon","c2"],"mappings":";;AAAA,OAAO,SAASA,aAAT,CAAuBC,UAAvB,EAAmCC,aAAnC,EAAkDC,WAAlD,EAA+D;AACpE,MAAMC,MAAM,GAAG,EAAf;;AADoE,sCAE/CF,aAF+C;AAAA,MAE/DG,KAF+D;AAAA,MAExDC,KAFwD;;AAGpE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,UAAU,CAACO,MAA/B,EAAuCD,CAAC,IAAI,CAA5C,EAA+C;AAC7C,QAAIE,CAAC,GAAGR,UAAU,CAACS,UAAX,CAAsBH,CAAtB,IAA2B,EAAnC;AAAA,QACEI,CAAC,GAAGV,UAAU,CAACS,UAAX,CAAsBH,CAAC,GAAG,CAA1B,IAA+B,EADrC,CAD6C,CAG7C;;AACAE,IAAAA,CAAC,GAAIA,CAAC,IAAI,CAAN,GAAW,EAAEA,CAAC,GAAG,CAAN,CAAf;AACAE,IAAAA,CAAC,GAAIA,CAAC,IAAI,CAAN,GAAW,EAAEA,CAAC,GAAG,CAAN,CAAf,CAL6C,CAM7C;;AACAF,IAAAA,CAAC,IAAIJ,KAAL;AACAM,IAAAA,CAAC,IAAIL,KAAL;AAEAD,IAAAA,KAAK,GAAGI,CAAR;AACAH,IAAAA,KAAK,GAAGK,CAAR,CAX6C,CAY7C;;AACAP,IAAAA,MAAM,CAACQ,IAAP,CAAY,CAACH,CAAC,GAAGN,WAAL,EAAkBQ,CAAC,GAAGR,WAAtB,CAAZ;AACD;;AACD,SAAOC,MAAP;AACD,C,CAED;;AACA,eAAe,SAASS,MAAT,CAAgBC,IAAhB,EAAsB;AACnC,MAAI,CAACA,IAAI,CAACC,YAAV,EAAwB,OAAOD,IAAP;AACxB,MAAIX,WAAW,GAAGW,IAAI,CAACE,SAAvB;;AACA,MAAI,CAACb,WAAL,EAAkB;AAChBA,IAAAA,WAAW,GAAG,IAAd;AACD;;AACDW,EAAAA,IAAI,CAACG,QAAL,CAAcC,OAAd,CAAsB,UAAAC,OAAO,EAAI;AACzB,QAAAC,QAAQ,GAAGD,OAAO,CAACC,QAAnB;AAAA,QACHC,WADG,GAC2BD,QAD3B,CACHC,WADG;AAAA,QACUnB,aADV,GAC2BkB,QAD3B,CACUlB,aADV;AAENmB,IAAAA,WAAW,CAACH,OAAZ,CAAoB,UAACjB,UAAD,EAAaqB,CAAb,EAAmB;AACrC,UAAIF,QAAQ,CAACG,IAAT,KAAkB,SAAtB,EAAiC;AAC/BF,QAAAA,WAAW,CAACC,CAAD,CAAX,GAAiBtB,aAAa,CAC5BC,UAD4B,EAE5BC,aAAa,CAACoB,CAAD,CAFe,EAG5BnB,WAH4B,CAA9B;AAKD,OAND,MAMO,IAAIiB,QAAQ,CAACG,IAAT,KAAkB,cAAtB,EAAsC;AAC3CtB,QAAAA,UAAU,CAACiB,OAAX,CAAmB,UAACM,OAAD,EAAUC,EAAV,EAAiB;AAClCxB,UAAAA,UAAU,CAACwB,EAAD,CAAV,GAAiBzB,aAAa,CAC5BwB,OAD4B,EAE5BtB,aAAa,CAACoB,CAAD,CAAb,CAAiBG,EAAjB,CAF4B,EAG5BtB,WAH4B,CAA9B;AAKD,SAND;AAOD;AACF,KAhBD;AAiBD,GApBD,EANmC,CA2BnC;;AACAW,EAAAA,IAAI,CAACC,YAAL,GAAoB,KAApB;AACA,SAAOD,IAAP;AACD","sourcesContent":["export function decodePolygon(coordinate, encodeOffsets, encodeScale) {\n  const result = []\n  let [prevX, prevY] = encodeOffsets\n  for (let i = 0; i < coordinate.length; i += 2) {\n    let x = coordinate.charCodeAt(i) - 64,\n      y = coordinate.charCodeAt(i + 1) - 64\n    // ZigZag decoding\n    x = (x >> 1) ^ -(x & 1)\n    y = (y >> 1) ^ -(y & 1)\n    // Delta decoding\n    x += prevX\n    y += prevY\n\n    prevX = x\n    prevY = y\n    // Dequantize\n    result.push([x / encodeScale, y / encodeScale])\n  }\n  return result\n}\n\n// 地图json解码\nexport default function decode(json) {\n  if (!json.UTF8Encoding) return json\n  let encodeScale = json.UTF8Scale\n  if (!encodeScale) {\n    encodeScale = 1024\n  }\n  json.features.forEach(feature => {\n    const geometry = feature.geometry,\n      {coordinates, encodeOffsets} = geometry\n    coordinates.forEach((coordinate, c) => {\n      if (geometry.type === 'Polygon') {\n        coordinates[c] = decodePolygon(\n          coordinate,\n          encodeOffsets[c],\n          encodeScale\n        )\n      } else if (geometry.type === 'MultiPolygon') {\n        coordinate.forEach((polygon, c2) => {\n          coordinate[c2] = decodePolygon(\n            polygon,\n            encodeOffsets[c][c2],\n            encodeScale\n          )\n        })\n      }\n    })\n  })\n  // has been decoded\n  json.UTF8Encoding = false\n  return json\n}\n"]}]}